<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/02/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <url>/2022/08/02/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先明确，<strong>Java中方法参数传递方式是按值传递</strong>。对于基本类型（int a, long b），参数传递时传递的是值，例如int a &#x3D; 5，传递的就是5。如果是引用类型，传递是指向具体对象内存地址的地址值，例如用System.out.println(new Object())打印出来的 java.lang.Object@7716f4 中 @符号后面的7716f4 就是16进制的内存地址，System.out.println实际上是默认调用了对象的toString方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到7716f4是由hashCode()输出的，如果有对象重写了hashCode方法，那输出的有可能就不是对象的初始内存地址了，所以如果要准确获得对象的初始地址建议调用System.identityHashCode()。</p><p>值得一提的是，在Java中获取一个对象的内存地址一般没有什么意义，因为它可能在程序运行过程中随着垃圾回收等动作被JVM更改。不过在下面我们可以根据引用的对象地址是否相同来看看参数传递的各种情况。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="基本类型作为参数传递"><a href="#基本类型作为参数传递" class="headerlink" title="基本类型作为参数传递"></a>基本类型作为参数传递</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//值传递举例</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;改之前的值:&quot;</span> + num);<br>        modify(num);<br>        System.out.println(<span class="hljs-string">&quot;改之后的值:&quot;</span> + num);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> num2)</span> &#123;<br>        num2 = <span class="hljs-number">11</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">改之前的值:<span class="hljs-number">10</span><br>改之后的值:<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>通过这个例子，说明<strong>基本数据类型作为参数传递时，传递的是值的拷贝，无论怎么改变这个拷贝，原值是不会改变的。</strong></p><h3 id="对象作为参数传递"><a href="#对象作为参数传递" class="headerlink" title="对象作为参数传递"></a>对象作为参数传递</h3><p>对象这里可以再划分一下，分为普通对象，集合类型和数组类型。下面依次来看一下效果</p><h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceBasicPass</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; val = x; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVal</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVal</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//普通对象</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;实参 node 指向的内存地址为：&quot;</span> + node.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;改之前的值:&quot;</span> + node.getVal());<br>        modify(node);<br>        System.out.println(<span class="hljs-string">&quot;改之后的值:&quot;</span> + node.getVal());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;形参 node 指向的内存地址为：&quot;</span> + node.hashCode());<br>        <span class="hljs-comment">//引用了同一块地址，操作了同一块堆内存</span><br>        node.setVal(<span class="hljs-number">11</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">实参 <span class="hljs-keyword">node</span> <span class="hljs-title">指向的内存地址为：366712642</span><br>改之前的值:<span class="hljs-number">10</span><br>形参 <span class="hljs-keyword">node</span> <span class="hljs-title">指向的内存地址为：366712642</span><br>改之后的值:<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>这说明，引用对象参数传递时，传递的是指向真实对象的地址，而函数中的形参node拿到同样的地址时，通过node.setVal(11)，会通过地址找到真实的对象进行操作。这里TreeNode没有重写hashCode方法，所以</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>由于ArrayList重写了hashcode()方法，所以这里使用System.identityHashCode拿到地址值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferencePass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//集合对象</span><br>        List&lt;TreeNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>));<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>));<br>        System.out.println(<span class="hljs-string">&quot;修改之前实参 node 指向的内存地址为：&quot;</span> + System.identityHashCode(nodes));<br>        System.out.println(<span class="hljs-string">&quot;修改之前实参 node 指向地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br>        modify(nodes);<br>        System.out.println(<span class="hljs-string">&quot;修改之后实参 node 指向的内存地址为：&quot;</span> + System.identityHashCode(nodes));<br>        System.out.println(<span class="hljs-string">&quot;修改之后实参 node 指向地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br><br>        System.out.println(<span class="hljs-string">&quot;\n------------------------------------------------\n&quot;</span>);<br>        modify2(nodes);<br>        System.out.println(<span class="hljs-string">&quot;再次修改之后实参 node 指向的内存地址为：&quot;</span> + System.identityHashCode(nodes));<br>        System.out.println(<span class="hljs-string">&quot;再次修改之后的实参 nodes 指向地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(List&lt;TreeNode&gt; nodes)</span> &#123;<br>        <span class="hljs-comment">//引用了同一块地址，操作了同一块堆内存</span><br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify2</span><span class="hljs-params">(List&lt;TreeNode&gt; nodes)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;形参 nodes 指向的内存地址：&quot;</span> + nodes.hashCode());<br>        <span class="hljs-comment">//形参nodes 指向了新的内存地址，对其进行操作但是不影响实参指向的内存地址的真实对象</span><br>        nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>));<br>        System.out.println(<span class="hljs-string">&quot;形参 nodes 指向的新内存地址：&quot;</span> + nodes.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;形参 nodes 指向新地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqlite">修改之前实参 node 指向的内存地址为：366712642<br>修改之前实参 node 指向地址存放的对象内容为：[&#123;&quot;val&quot;:1&#125;,&#123;&quot;val&quot;:2&#125;]<br>修改之后实参 node 指向的内存地址为：366712642<br>修改之后实参 node 指向地址存放的对象内容为：[&#123;&quot;val&quot;:1&#125;,&#123;&quot;val&quot;:2&#125;,&#123;&quot;val&quot;:3&#125;]<br><br>------------------------------------------------<br><br>形参 nodes 指向的内存地址：1110478811<br>形参 nodes 指向的新内存地址：1458540949<br>形参 nodes 指向新地址存放的对象内容为：[&#123;&quot;val&quot;:5&#125;]<br>再次修改之后实参 node 指向的内存地址为：366712642<br>再次修改之后的实参 nodes 指向地址存放的对象内容为：[&#123;&quot;val&quot;:1&#125;,&#123;&quot;val&quot;:2&#125;,&#123;&quot;val&quot;:3&#125;]<br></code></pre></td></tr></table></figure><p>对于集合，传递的也是引用的地址，函数内通过形参得到引用地址的拷贝后再操作真实对象，导致实参访问真实对象时已经被修改过了。如果形参指向了新的内存地址，则修改不会影响到原对象的值。</p><p>注：JsonUtils是用Jackson实现的。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>普通数组，和集合一样是引用类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceArrayPass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//普通数组，和集合一样是引用类型，数组本质上也是</span><br>        <span class="hljs-type">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        ints[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        ints[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        System.out.println(<span class="hljs-string">&quot;实参 ints 指向的内存地址为：&quot;</span> + System.identityHashCode(ints));<br>        System.out.println(<span class="hljs-string">&quot;修改之前 ints 索引为2的值&quot;</span> + ints[<span class="hljs-number">2</span>]);<br>        modify(ints);<br>        System.out.println(<span class="hljs-string">&quot;修改之后 ints 索引为2的值&quot;</span> + ints[<span class="hljs-number">2</span>]);<br>        <span class="hljs-comment">//普通数组的class为[I ， I表示int型</span><br>        System.out.println(ints.getClass());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ints)</span> &#123;<br>        <span class="hljs-comment">//引用了同一块地址，操作了同一块堆内存</span><br>        System.out.println(<span class="hljs-string">&quot;形参 ints 指向的内存地址为：&quot;</span> + System.identityHashCode(ints));<br>        ints[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">实参 <span class="hljs-built_in">int</span>s 指向的内存地址为：<span class="hljs-number">366712642</span><br>修改之前 <span class="hljs-built_in">int</span>s 索引为<span class="hljs-number">2</span>的值：<span class="hljs-number">0</span><br>形参 <span class="hljs-built_in">int</span>s 指向的内存地址为：<span class="hljs-number">366712642</span><br>修改之后 <span class="hljs-built_in">int</span>s 索引为<span class="hljs-number">2</span>的值：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>数组与集合的情况也是一样的。</p><h3 id="基本类型的包装类型"><a href="#基本类型的包装类型" class="headerlink" title="基本类型的包装类型"></a>基本类型的包装类型</h3><p>值得注意的是，对于基本类型的包装类型，其参数传递也是属于地址值传递；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//值传递举例</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;before modify result:&quot;</span> + num);<br>        modify(num);<br>        System.out.println(<span class="hljs-string">&quot;after modify result:&quot;</span> + num);<br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">&quot;before modify result:&quot;</span> + integer);<br>        modify(num);<br>        System.out.println(<span class="hljs-string">&quot;after modify result:&quot;</span> + integer);<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> num2)</span> &#123;<br>        num2 = <span class="hljs-number">11</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(Integer integer)</span> &#123;<br>        integer = <span class="hljs-number">21</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">before modify result:<span class="hljs-number">10</span><br>after modify result:<span class="hljs-number">10</span><br>before modify result:<span class="hljs-number">20</span><br>after modify result:<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>而由于jdk1.5以上的自动装箱特性，Integer i &#x3D; 20 等价于执行 Integer i &#x3D; Integer.valueOf(20) ，valueOf()方法参看源码会根据传入的数值 如果在-128-127之间 就从常量池中获取一个Integer对象返回，如果不在范围内 会new Integer(20)返回。</strong></p><img src="/Users/xiaohai/Library/Application Support/typora-user-images/image-20211124225444095.png" alt="image-20211124225444095" style="zoom:50%;" /><p><strong>即是说Integer的地址会随着值的改变而改变，这其实就是引用类型的赋值，指向了新的内存地址了，例如上面integer &#x3D; 21的例子， 即等价于integer &#x3D; Integer.valueOf(21)，不管21之前是否有创建过，integer都指向了新的内存地址，但是并不影响实参，外部依旧是20</strong></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/1961146/memory-address-of-variables-in-java">https://stackoverflow.com/questions/1961146/memory-address-of-variables-in-java</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java核心技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
