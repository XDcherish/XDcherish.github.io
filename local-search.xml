<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一种能彻底解决缓存三大难题的缓存方案</title>
    <link href="/2022/08/01/%E4%B8%80%E7%A7%8D%E8%83%BD%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%9A%BE%E9%A2%98%E7%9A%84%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88/"/>
    <url>/2022/08/01/%E4%B8%80%E7%A7%8D%E8%83%BD%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%9A%BE%E9%A2%98%E7%9A%84%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://juejin.cn/post/7124541481259368462">【缓存系列】几种缓存读写方案的优缺点和选择</a>中我们介绍了传统的几种缓存读写方案，并分析了它们适合在什么场景下使用，会遇到什么样的问题，以及怎么去解决。</p><p>而在并发较高的情况下，甚至会造成更为严重的问题，主要有三大类，缓存雪崩、击穿以及穿透，定义和解决方案可以参考之前的文章<a href="https://juejin.cn/post/7124723299052945416">【缓存系列】彻底解决缓存雪崩、击穿、穿透问题</a>。</p><p>仔细思考一下它们产生的原因，本质上都是由于读操作中的”获取缓存-如果没有-则查DB”的逻辑导致的，那如果对于某些极度依赖缓存的场景，是不是可以换一种思路，直接以缓存为主数据源，即查询缓存，有直接返回，没有也不会去查DB了。缓存的更新通过监听数据库的变更记录实现，比如监听Mysql的binlog，可将变更记录投递到 MQ 系统中，例如 Kafka&#x2F;RocketMQ。</p><p>我们来具体看下这个方案。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><h4 id="增量"><a href="#增量" class="headerlink" title="增量"></a>增量</h4><ol><li>先更新DB；</li><li>监听binlog消息实时更新Cache；</li></ol><h4 id="存量"><a href="#存量" class="headerlink" title="存量"></a>存量</h4><ol><li>全量数据同步task，用于上线前全量初始化Cache数据</li><li>为保证binlog消息可能丢失带来的影响，初始化task每半天跑一次</li></ol><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ol><li>从Cache中读数据</li><li>直接返回读取的数据（Cache中没有的数据默认表示DB中的数据也没有）</li></ol><p>关于监听Mysql数据变更的binlog之后发送到消息队列中的功能，可以使用一些现有的组件来配合实现，例如阿里巴巴开源的<strong>canal</strong>，</p><img src="/imgs/一种能彻底解决缓存三大难题的缓存方案/d5abce1ce87b4109bfac997ff2999e29~tplv-k3u1fbpfcp-zoom-1.png" alt="image-20220725135145017" style="zoom:50%;" /><p>其原理大致如下：</p><ul><li>canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议</li><li>MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</li><li>canal 解析 binary log 对象(原始为 byte 流)</li><li>发送到指定消息队列中，供其他系统进行消费</li></ul><p>更多接入细节可以参考其官网<a href="https://github.com/alibaba/canal%E3%80%82">https://github.com/alibaba/canal。</a></p><p>不过，像在一些比较大的公司，都会有基础架构的同学负责提供这样的数据传输服务（DTS），业务方负责订阅使用即可。</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>对于Cache中存储的数据结构，只能存储与其数据表有关的数据，举个例子。</p><p>以商品数据为例，先简单介绍下商品的数据结构（后面有机会单独出一篇文章详细介绍～）；</p><img src="/imgs/一种能彻底解决缓存三大难题的缓存方案/9e71a934f477406286603a438f707faf~tplv-k3u1fbpfcp-watermark.png" alt="image-20220725135145017" style="zoom:50%;" /><p>商品类目是指商品的分类，比如一级分类为数码产品，二级分类为手机；</p><p>商品SPU（Standard Product Unit）是指标准化产品单元，即以一个产品为一个单位。比如手机类目里面的Iphone13可以当作一个单位。</p><p>商品SKU（Stock Keeping Unit）是指库存量单元，库存一般会记录到更细致的粒度，比如Iphone13 远峰蓝色 256G，Iphone13 土豪金色 128G。颜色和内存被称作规格，所有规格的组合唯一确定商品的一个SKU。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `category` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;类目名称&#x27;</span>,<br>  <br>  ...<br>) ENGINE<span class="hljs-operator">=</span>InnoDB ;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `product` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品名称&#x27;</span>,<br>  `category_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品类目&#x27;</span>,<br>  `url` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品名称&#x27;</span>,<br>  <br>  ...<br>) ENGINE<span class="hljs-operator">=</span>InnoDB ;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `product_sku` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `product_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品类目&#x27;</span>,<br>  `price` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;价格&#x27;</span>,<br><br>  ...<br>) ENGINE<span class="hljs-operator">=</span>InnoDB ;<br></code></pre></td></tr></table></figure><p>查询SKU至少会有两个维度：</p><ol><li>通过product_id查询该商品下所有的SKU。比如进入商品详情页时，列出所有可订购的选项；</li></ol><img src="/imgs/一种能彻底解决缓存三大难题的缓存方案/e7ea913aece249ec8fecd261f8a4fb1e~tplv-k3u1fbpfcp-watermark.png" alt="image-20220725135145017" style="zoom:50%;" /><ol start="2"><li>通过sku_id查询唯一确定的一行记录。比如选择某一个SKU后进入订单确认页；</li></ol><img src="/imgs/一种能彻底解决缓存三大难题的缓存方案/dbc14888a3f240b09f3a2b70afc66f10~tplv-k3u1fbpfcp-watermark.png" alt="image-20220725135145017" style="zoom:50%;" /><p>这两种维度存储到Redis中分别使用String和Hash类型存储；</p><ul><li>String类型：key是唯一键（sku_id），存储整个do对象；</li><li>Hash类型：key是外键（product_id），field是唯一键（sku_id），存储的是整个do对象；</li></ul><blockquote><p>一般这两种维度是最常用的，可以考虑把这部分使用做一下封装，例如让业务方做一点配置就可以轻松实现缓存接入，例如配置Mybatis中的domain，example，mapper等信息，通过反射实现通用接入功能，而不需要自己去解析binlog消息的变更。</p></blockquote><p>除了上面最常用的两种维度以外，还有很多特殊的维度，例如想要统计手机类目下所有在线的商品数量有多少，实现思路如下：</p><ol><li>存储结构为String类型，key是外键（category_id），value是商品数量。</li><li>监听product表的insert，update，delete（推荐软删除）操作，insert时如果sale_status字段为上架状态，数量 + 1；update需要判断更新前 和 更新后sale_status的状态，如果由上架改为下架，数量 - 1，反之 + 1，一样则不变。delete时需要判断之前是否为上架状态，是则 - 1。</li></ol><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>由于Cache数据作为了主要的数据源，所以也就不存在缓存击穿、雪崩和穿透问题了。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><h3 id="1-消息延迟"><a href="#1-消息延迟" class="headerlink" title="1.消息延迟"></a>1.消息延迟</h3><p>接收到消息平均可能会有大概几百毫秒的延迟，并且如果消息发送有问题，或者消息如果处理有问题会导致数据不一致的影响扩大。</p><h3 id="2-消息乱序"><a href="#2-消息乱序" class="headerlink" title="2.消息乱序"></a>2.消息乱序</h3><p>由于消息消费一般都是无序的形式，所以需要进行数据的版本对比，一般会选择用<strong>更新时间戳</strong>或者单独的<strong>版本号</strong>，如果选择的是时间戳，只要收到的消息的更新时间要早于当前缓存中的更新时间，则表示是旧消息，直接忽略该消息即可。</p><h3 id="3-消息丢失"><a href="#3-消息丢失" class="headerlink" title="3.消息丢失"></a>3.消息丢失</h3><p>我们都知道，消息是可能会丢失的，所以为了避免消息丢失带来数据不一致的影响，可以把全量同步task设定为定时任务，控制一下流量，保证不会由于一直没有更新操作导致数据一直不一致。</p><h3 id="4-应用场景有限"><a href="#4-应用场景有限" class="headerlink" title="4.应用场景有限"></a>4.应用场景有限</h3><p>由于会把数据表中的数据全部同步到缓存中，所以不适合数据量很大的业务，比如订单业务。但Redis一个单实例最多能存2的32次方的key，最少也能存2.5亿的key，所以集群场景下通常是能接受缓存key很多的，只是单个key不宜很大。</p><p>另外之前介绍了像类目下所有的商品数这种比较缓存方式，使用该模式来实现不一定简单。</p>]]></content>
    
    
    <categories>
      
      <category>缓存系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>缓存</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>彻底解决缓存雪崩、击穿、穿透问题</title>
    <link href="/2022/07/15/%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/15/%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>缓存雪崩是指在短时间内，有大量缓存同时过期，导致此时大批量请求均未命中缓存，从而直接查询数据库并对数据库造成了巨大的压力，严重情况下可能会导致数据库宕机，这种情况称作缓存雪崩。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一：随机化过期时间"><a href="#方案一：随机化过期时间" class="headerlink" title="方案一：随机化过期时间"></a>方案一：随机化过期时间</h4><p>在介绍Cache Aside Pattern的时候我们对缓存统一设置了60s的过期时间，并对热点key的缓存在服务发布的时候提前初始化好了。</p><p>这样做的话，过了60s之后，热点key的缓存会统一时间过期，那大部分流量会进入加载DB数据进缓存的逻辑。所以，我们可以尝试对缓存过期的时间设置一个范围随机数，比如60s ~ 120s，这样有一部分缓存晚一些过期，分摊一些进入DB加载数据的压力。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">cacheService</span>.set(key, <span class="hljs-class"><span class="hljs-keyword">data</span>, 60 + new <span class="hljs-type">Random</span>().nextInt(60));</span><br></code></pre></td></tr></table></figure><p>随机时间范围的选择根据实际业务来决定，一般过期时间设置的比较分散的情况下就能较大程度减少缓存雪崩发生的概率。</p><h4 id="方案二：缓存数据永不过期"><a href="#方案二：缓存数据永不过期" class="headerlink" title="方案二：缓存数据永不过期"></a>方案二：缓存数据永不过期</h4><p>既然缓存雪崩的问题是缓存统一过期导致的，那缓存数据在更新的时候可以不设置过期时间，然后更新DB的操作不能删除Cache，改为更新Cache。整个更新操作需要对热点key加锁，否则会出现之前提到过的数据不一致问题。</p><p>有小伙伴会问，如果有时候更新DB成功了，但更新Cache失败了，从而导致后面的查询不是最新数据的情况该怎么办呢？</p><p>这里可以设计一个<strong>定时任务</strong>，比如每小时把所有数据查询DB数据刷一下缓存，保证之前更新失败造成的影响不会很大。</p><p>但这样的方式并不适用与所有业务，如果缓存的数据过多，会很占用缓存资源。可以适当做一些挑选，设置相对请求量更大的key永不过期即可。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>缓存击穿是指对于某一个<strong>热点缓存</strong>，如果缓存过期的同时刚好有大量的并发请求，由于没有做并发控制，他们很可能同时绕过<code>if(data == null)</code>判断条件，进入加载DB数据进缓存的逻辑，从而给DB造成巨大压力甚至宕机，这样的情况称为<strong>缓存击穿</strong>。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>缓存击穿实际上可以理解为一种特殊的缓存雪崩，所以给出的解决方案可以是在缓存雪崩的基础上再做进一步的优化。</p><h4 id="方案一：加锁排队"><a href="#方案一：加锁排队" class="headerlink" title="方案一：加锁排队"></a>方案一：加锁排队</h4><p><strong>随机化过期时间</strong>基本上能大幅度降低不同缓存key同时过期的概率，在其方案的基础上，对某一个key读取缓存不存在之后加载DB的逻辑做<strong>并发控制</strong>，也就能较好地解决缓存雪崩和缓存击穿问题了。</p><p>并发控制的具体逻辑，这里举个例子说明一下。</p><p>假设当前对某一个key的并发请求数为1000，那势必会有某一个请求先获取到锁，然后去DB加载数据会更新到Cache。而剩余的999个请求会被锁拦住，但这里不会直接报错，而是设置一个等待时间，比如2s。</p><p>当请求1更新Cache之后，释放锁。剩余999个请求依次排队获取锁，当请求2获取到锁进入加载逻辑之后，由于请求1已经更新了Cache，所以其实这里可以再次查询一次Cache，查询到就直接返回了，无需再加载一次数据。</p><p>但2s的等待时间内，可能只能处理199个请求，那现在还剩下800个请求，会进入获取锁超时失败的流程。实际上请求1已经更新了Cache了，所以获取锁失败的流程就是再查询一次Cache，有则返回，否则报错系统繁忙。</p><p>结合代码理解一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataCacheManager</span> &#123;<br>    <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">query</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;keyPrefix:&quot;</span> + id;<br>        <span class="hljs-comment">//查询缓存</span><br>        <span class="hljs-type">Data</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> cacheService.get(key);<br>        <span class="hljs-keyword">if</span>(data == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                cacheService.lock(key, <span class="hljs-number">2</span>);<br>                  <span class="hljs-comment">//先查Cache</span><br>                  <span class="hljs-type">Data</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> cacheService.get(key);<br>                  <span class="hljs-keyword">if</span>(data != <span class="hljs-literal">null</span>) &#123;<br>                      <span class="hljs-keyword">return</span> data;<br>                &#125;<br>                <span class="hljs-comment">//查询DB</span><br>                data = dataDao.get(id);<br>                <span class="hljs-comment">//更新缓存</span><br>                cacheService.set(key, data); <br>            &#125; <span class="hljs-keyword">catch</span> (tryLockTimeoutException e) &#123;<br>                    <span class="hljs-comment">//超时后再查一次缓存，存在则返回，否则抛出异常</span><br>                  data = dataDao.get(id);<br>                  <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span>) &#123;<br>                      <span class="hljs-keyword">return</span> data;<br>                  &#125;<br>                  <span class="hljs-keyword">throw</span> e;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cacheService.unLock(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方案二：热点数据永不过期"><a href="#方案二：热点数据永不过期" class="headerlink" title="方案二：热点数据永不过期"></a>方案二：热点数据永不过期</h4><p>同样的，缓存击穿问题也是由于Cache过期导致的，只要将热点数据的Cache设置为永不过期即可避免。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>缓存击穿是指缓存和数据库中都没有的数据，可用户还是源源不断的发起大量请求，导致每次请求都会到数据库，从而压垮数据库。</p><p>通常情况下按照正常的页面操作走是不会出现这个情况的，比如从电商首页或者列表页点进去的商品是一定存在的。但可能有人伪造http请求，并改了goodsId为0之后发起大量的请求，目的就是搞垮你的系统～ 所以需要提前预防悲剧的发生。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一：参数校验"><a href="#方案一：参数校验" class="headerlink" title="方案一：参数校验"></a>方案一：参数校验</h4><p>客户端发过来的请求，对参数进行校验，对于不满足检查条件的情况下直接拦截。比如商品id肯定不会小于0，避免请求打到下游。</p><p>很显然，该方案不能完全杜绝穿透的发生，如果传了一个正常的数字，比如goodsId &#x3D; 666666，正好又没有该商品，就拦不住了。</p><h4 id="方案二：缓存空值"><a href="#方案二：缓存空值" class="headerlink" title="方案二：缓存空值"></a>方案二：缓存空值</h4><p>既然是因为请求了DB没有的数据，那把这样的数据也存储的Cache中去就好了，可以存个”null”之类的值，保证不和正常结构一致就行，后面查询出来识别是”null”之后直接返回null即可。</p><p>不过，最好设置一个合理的过期时间，因为key对应数据不一定一直为null。</p><h4 id="方案三：布隆过滤器（Bloom-Filter）"><a href="#方案三：布隆过滤器（Bloom-Filter）" class="headerlink" title="方案三：布隆过滤器（Bloom Filter）"></a>方案三：布隆过滤器（Bloom Filter）</h4><p>关于布隆过滤器，后面会详细介绍。其原理不难，它是一种数据结构，利用极小的内存，可以判断大量的数据“一定不存在或者可能存在”。</p><p>对于缓存穿透，我们可以将查询的数据条件都哈希到一个足够大的布隆过滤器中，请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了，从而避免下一步对DB的压力，可能存在的数据可以走到DB实际查询，但概率不大所以影响很小。</p><h2 id="兜底方案：DB限流-amp-降级"><a href="#兜底方案：DB限流-amp-降级" class="headerlink" title="兜底方案：DB限流&amp;降级"></a>兜底方案：DB限流&amp;降级</h2><p>缓存雪崩、击穿、穿透三个问题说到底就是将数据库打卦了，所以核心问题在于如何保证数据库不会被打卦。</p><p>从数据库层面来考虑，它控制不了你到底来多少请求，肯定是不会完全相信你做的那些优化保证的，万一你写的代码有bug呢对吧～最保险的方式就是给自己设上防护，这个防护就是限流。</p><p>假设你设置了1s能通过1000个请求的限流，如果此时来了2000个请求，前1000个正常执行，后1000个触发了限流，可以走你配置的降级逻辑，比如返回一些配置的默认值，或者给个友好的报错提示等。这里的限流最好是有针对性的，比如某个热点表的读请求拥有单独的限流配置，保证不影响到其他正常的请求被限流。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不知道你有没有发现，有一个方案能同时解决缓存雪崩和缓存穿透的问题，那就是使数据永不过期。但它只适用于缓存key不会很多的场景，不过实际上我们大部分同学所做的业务的缓存key并不会太多，甚至一些较大的电商项目，也有很多的场景是适用的。</p><p>比如商品的缓存，一般最多也就几亿到几十亿，Redis一个单实例最多能存2的32次方的key，最少也能存2.5亿的key，所以集群场景下通常是能接受缓存key很多的，只是单个key不宜很大。</p><p>甚至，如果在缓存永不过期的基础上，以缓存的数据为主要数据源（Cache中查询不到不去查询DB了），还能解决穿透的问题。话说我在工作中就专门封装了这样一个框架，已经接入商品，活动等系统了，后续写完了分享出来～（已经写完啦，<a href="https://juejin.cn/post/7126544551304495117">【缓存系列】一种能彻底解决缓存三大难题的缓存方案</a>）</p>]]></content>
    
    
    <categories>
      
      <category>缓存系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>缓存</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几种缓存读写方案的优缺点和选择</title>
    <link href="/2022/07/01/%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E9%80%89%E6%8B%A9/"/>
    <url>/2022/07/01/%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常开发中，缓存是提升系统瓶颈的最简单方法之一，如果缓存使用得当，缓存可以增加系统吞吐量，减少响应时间、减少数据库负载等。</p><p>但在不同的场景下，所适用缓存读写策略是不尽相同的，这篇文章将介绍不同缓存读写策略在不同场合下的使用与存在问题的分析，并给出解决方案～</p><h2 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h2><p>Cache Aside Pattern 意为旁路缓存模式，是我们平时最常用的一个缓存读写模式，应用程序需要一起操作 DB 和 Cache，并且以 DB 的数据为准。<br>下面我们来看一下这个模式下的缓存读写步骤。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><ol><li><p>更新 DB</p></li><li><p>删除 Cache</p></li></ol><h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><ol><li><p>从 Cache 中读取数据，有数据直接返回</p></li><li><p>Cache中没数据的话，从 DB 中读取数据，数据更新到 Cache 中后返回。</p></li></ol><h3 id="代码实施"><a href="#代码实施" class="headerlink" title="代码实施"></a>代码实施</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataCacheManager</span> &#123;<br><br>    <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">query</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;keyPrefix:&quot;</span> + id;<br>        <span class="hljs-comment">//查询缓存</span><br>        <span class="hljs-type">Data</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> cacheService.get(key);<br>        <span class="hljs-keyword">if</span>(data == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//查询DB</span><br>            data = dataDao.get(id);<br>            <span class="hljs-comment">//更新缓存</span><br>            cacheService.set(key, data);<br>        &#125;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">update</span><span class="hljs-params">(Data data)</span> &#123;<br>        <span class="hljs-comment">//更新DB</span><br>        data = dataDao.update(data);<br>        <span class="hljs-comment">//更新缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;keyPrefix:&quot;</span> + data.getId();<br>        cacheService.del(key);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在工作中的时候，我的应用分层是按照《阿里巴巴Java开发手册》进行的，如下图所示。所以我一般会将缓存的这块逻辑单独抽离，介于Dao层和Service层之间的Manager中实现，这样多个Service通常可以复用这样的缓存代码。</p><p><img src="/imgs/%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E9%80%89%E6%8B%A9/841a623c23f94e42a19db1d67ec2ac92~tplv-k3u1fbpfcp-watermark-20220823160159228.png"></p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>看完上面的方案，可能你心里会有一些疑惑，为什么是删除缓存，而不是更新缓存？为什么是先更新DB，再删除Cache，可以交换下顺序吗？按照Cache Aside Pattern的实现，先更新DB，后删除Cache就一定没有问题了吗？我们一个个来分析。</p><h4 id="1-为什么是删除缓存，而不是更新缓存？"><a href="#1-为什么是删除缓存，而不是更新缓存？" class="headerlink" title="1.为什么是删除缓存，而不是更新缓存？"></a>1.为什么是删除缓存，而不是更新缓存？</h4><p>从直观的角度上来看，更新操作，直接把缓存一起更新了应该是个更容易理解的方案。但从性能和安全的角度上来看，直接更新缓存就不一定是合理的了。</p><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>对于一些比较大的key，更新Cache比删除Cache更耗费性能。甚至当写操作比较多时，可能会存在刚更新的缓存还没有被读过，又再次被更新的情况（这常被称为缓存扰动），导致缓存利用率不高。所以，基于懒加载的思想，不用就没必要存在，所以Cache Aside更支持直接del。</p><p>实际上，一般key也不会太大，而且我在生产中使用缓存的场景读请求流量也不会低，所以对于性能的影响个人感觉还好。</p><h5 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h5><p>在并发场景下，多个写请求同时更新缓存可能会造成数据不一致的问题，看下面这个过程：</p><table><thead><tr><th align="center">写请求1</th><th align="center">写请求2</th><th align="center">读请求3</th></tr></thead><tbody><tr><td align="center">更新数据A到DB</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">更新数据B到DB</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">更新数据B到Cache</td><td align="center"></td></tr><tr><td align="center">更新数据A到Cache</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">查询Cache数据，读取到A</td></tr></tbody></table><p>由于线程调度等原因，写请求 1 的更新Cache操作晚于写请求 2 中的更新Cache操作，这样会导致最终写入缓存中的是来自写请求 1 的数据A，从而使得后面的读操作读取到的都是旧值。</p><h4 id="2-为什么是先更新DB，再删除Cache，可以交换下顺序吗？"><a href="#2-为什么是先更新DB，再删除Cache，可以交换下顺序吗？" class="headerlink" title="2.为什么是先更新DB，再删除Cache，可以交换下顺序吗？"></a>2.为什么是先更新DB，再删除Cache，可以交换下顺序吗？</h4><p>同样地，先删除Cache，再更新DB，也可能会造成DB数据和Cache数据的不一致。为什么呢？看下面这个过程：</p><table><thead><tr><th align="center">写请求1</th><th align="center">读请求2</th><th align="center">读请求3</th></tr></thead><tbody><tr><td align="center">删除Cache数据A</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">查询Cache数据A不存在</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">从DB读取数据A</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">更新数据A到Cache</td><td align="center"></td></tr><tr><td align="center">更新数据B到DB</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">查询Cache数据，读取到A</td></tr></tbody></table><p>当多个请求<strong>并发</strong>时，写请求1的两个操作之间穿插了请求2的所有操作（主要是写DB比较慢，需要分配更多的时间片才能执行完成），导致Cache的数据没有正确更新。只有等下次更新或者缓存自动过期后才会把最新的数据B存入缓存，如果是更新则有可能再次发生这样的问题，导致一直不一致…</p><h4 id="3-按照Cache-Aside-Pattern的实现，先更新DB，后删除Cache就一定没有问题了吗？"><a href="#3-按照Cache-Aside-Pattern的实现，先更新DB，后删除Cache就一定没有问题了吗？" class="headerlink" title="3.按照Cache Aside Pattern的实现，先更新DB，后删除Cache就一定没有问题了吗？"></a>3.按照Cache Aside Pattern的实现，先更新DB，后删除Cache就一定没有问题了吗？</h4><p>理论上来说还是可能会出现数据不一致性的问题，看下面这个过程：</p><table><thead><tr><th align="center">请求1</th><th align="center">请求2</th><th align="center">请求3</th></tr></thead><tbody><tr><td align="center">查询Cache，不存在</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">从DB读取数据A</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">更新数据B到DB</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">删除Cache数据A</td><td align="center"></td></tr><tr><td align="center">更新数据A到Cache</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">查询Cache，读取到数据A</td></tr></tbody></table><p>同样可能由于线程调度等原因，读请求 1 的更新Cache操作晚于写请求 2 中的删除Cache操作，这样会导致最终写入缓存中的是来自请求 1 的旧值A，而写入数据库中的是来自请求 2 的新值B，即缓存数据落后于数据库，此时再有读请求 3 命中缓存，读取到的便是旧值A。</p><p>但与之前不同的是，这种场景出现的概率要小许多，因为更新DB所需的线程调度时间要远大于更新Cache，所以一般情况下都是Cache先执行完成。</p><h4 id="4-Cache-Aside-Pattern如何完全杜绝数据不一致问题？"><a href="#4-Cache-Aside-Pattern如何完全杜绝数据不一致问题？" class="headerlink" title="4.Cache Aside Pattern如何完全杜绝数据不一致问题？"></a>4.Cache Aside Pattern如何完全杜绝数据不一致问题？</h4><p>两个字，<strong>加锁</strong>，单机加JVM锁，集群加分布式锁。</p><p>对于写操作，需要将更新DB和删除Cache锁住，</p><p>对于读操作，需要将查询Cache不存在之后的操作锁住。</p><p>并且需要注意读操作和写操作的锁需要使用一把！！！即读操作没有命中缓存的时候不能进行写操作，反之同理。</p><p>来优化下之前的代码，假设是集群环境，使用分布式锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataCacheManager</span> &#123;<br><br>    <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">query</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;keyPrefix:&quot;</span> + id;<br>        <span class="hljs-comment">//查询缓存</span><br>        <span class="hljs-type">Data</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> cacheService.get(key);<br>        <span class="hljs-keyword">if</span>(data == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                cacheService.lock(key, <span class="hljs-number">2</span>);<br>                <span class="hljs-comment">//查询DB</span><br>                data = dataDao.get(id);<br>                <span class="hljs-comment">//更新缓存</span><br>                cacheService.set(key, data); <br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cacheService.unLock(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-meta">@RedisLock(keySuffix = &quot;#data.id&quot;, keyPrefix = &quot;keyPrefix:&quot;)</span><br>    <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">update</span><span class="hljs-params">(Data data)</span> &#123;<br>        <span class="hljs-comment">//更新DB</span><br>        data = dataDao.update(data);<br>        <span class="hljs-comment">//更新缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;keyPrefix:&quot;</span> + data.getId();<br>        cacheService.del(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：对@RedisLock不熟悉的推荐参考下<a href="https://juejin.cn/post/7069768248635424775">巧用 分布式锁 🔥 - 掘金</a>，能更简单的使用分布式锁～</p></blockquote><p>不过，加锁势必会影响性能，导致系统吞吐量下降，并发高时可能还会造成堵塞线程过多从而OOM。</p><h4 id="5-Cache-Aside-Pattern如何尽量降低数据不一致的影响？"><a href="#5-Cache-Aside-Pattern如何尽量降低数据不一致的影响？" class="headerlink" title="5.Cache Aside Pattern如何尽量降低数据不一致的影响？"></a>5.Cache Aside Pattern如何尽量降低数据不一致的影响？</h4><p>既然加锁会降低性能，如果能接受短暂时间的数据不一致场景，应该怎么尽量降低其影响呢？</p><p>解决办法就是更新Cache的同时给Cache增加一个比较<strong>短的过期时间</strong>，这样可以保证即使数据不一致的话影响也比较小。</p><p>但如果在短时间内，有大量缓存同时过期，导致大量的请求直接查询数据库，从而对数据库造成了巨大的压力，严重情况下可能会导致数据库宕机，这种情况叫做缓存雪崩。缓存雪崩的解决方案稍后再讨论，接着往下看～</p><h4 id="6-Cache-Aside-Pattern首次读请求问题"><a href="#6-Cache-Aside-Pattern首次读请求问题" class="headerlink" title="6.Cache Aside Pattern首次读请求问题"></a>6.Cache Aside Pattern首次读请求问题</h4><p>对于第一次读取的Cache，数据一定不在Cache中，如果服务发布后一下来很多个读请求，很可能同时绕过<code>if(data == null)</code>判断条件从而一起请求DB，造成压力过大。</p><p>如何解决这个问题呢？</p><p>可以将热点数据提前加载到Cache中，比如读取配置获取热点数据Key，然后使用<code>@PostConstruct</code>注解在服务启动之前加载数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataCacheManager</span> &#123;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//假设配置的热点id为520，666</span><br>        List&lt;Long&gt; hotIds = Lists.newArrayList(<span class="hljs-number">520L</span>, <span class="hljs-number">666L</span>);<br>        <span class="hljs-keyword">for</span> (Long hotId : hotIds) &#123;<br>            <span class="hljs-type">Data</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> dataDao.get(hotId);<br>            <span class="hljs-comment">//更新缓存</span><br>            cacheService.set(key, data, <span class="hljs-number">60</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>由上述分析，该方案适合<strong>读多写少</strong>的场景，并且尽量使用在对数据一致性要求没有那么高的场景，例如商品详情页的商品数据缓存，商品描述和价格等信息变化的频次一般都很低，即使价格有变化，在下单的时候订单系统会读取最新的商品价格，确保数据准确。</p><h2 id="Read-Through-Pattern"><a href="#Read-Through-Pattern" class="headerlink" title="Read Through Pattern"></a>Read Through Pattern</h2><p>Read-Through 意为读穿透模式，它的流程和 Cache-Aside 读操作基本类似，不同点在于 Read-Through 中多了一个访问控制层，应用读请求只和访问控制层进行交互，而背后缓存命中与否的逻辑则由访问控制层与数据源进行交互。</p><p>这样做可以使业务层的实现会更加简洁，并且对于缓存层及持久化层的交互封装做得更好，可以更轻松的扩展和迁移。</p><h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h3><ol><li><p>应用程序读请求访问控制层</p></li><li><p>访问控制层从 Cache 中读取数据，读取到就直接返回。</p></li><li><p>读取不到的话，先从 DB 加载，写入到 Cache 后返回。</p></li></ol><p><img src="/imgs/%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E9%80%89%E6%8B%A9/31d5d8047e394699a6acc9f294bbe137~tplv-k3u1fbpfcp-watermark-20220823160159039.png" alt="image-20220725135145017.png"></p><p>举个例子，著名的本地缓存Guava Cache采用的就是该模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化</span><br>LoadingCache&lt;String, Data&gt; loadingCache = CacheBuilder.newBuilder()<br>            .maximumSize(<span class="hljs-number">1000</span>)<br>            .expireAfterAccess(<span class="hljs-number">1</span>, TimeUnit.MINUTES)<br>            .build(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheLoader</span>&lt;String, Data&gt;() &#123;<br>                        <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">load</span><span class="hljs-params">(String key)</span> &#123;<br>                            <span class="hljs-keyword">return</span> dataDao.query(key);<br>                        &#125;<br>                    &#125;<br>            );<br><br><span class="hljs-comment">//读操作，里面包含了 获取缓存-如果没有-则计算&quot;[get-if-absent-compute]的原子语义</span><br>loadingCache.get(key);<br></code></pre></td></tr></table></figure><p>实际上，在Cache Aside Pattern 中的实现上我们通过将缓存的逻辑抽离到Manager层中，一定程度上也算是勉强达到了降低应用层复杂度的效果（主要是将Service层当作了应用层）。</p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>该方案适合<strong>读请求多</strong>的场景，并且对数据一致性要求没有那么高的场景。另外，该方案也同样存在首次读取问题，可以在初始化时模拟外部读请求使数据能提前加载。</p><h2 id="Write-Through-Pattern"><a href="#Write-Through-Pattern" class="headerlink" title="Write Through Pattern"></a>Write Through Pattern</h2><p>Write-Through 意为写穿透模式，它也增加了访问控制层来提供更高程度的封装。不同于 Cache-Aside 的是，Write-Through 直写模式在写请求更新Cache之后，更新DB，并且这两步操作需要控制层保证是一个原子操作。</p><h3 id="方案-2"><a href="#方案-2" class="headerlink" title="方案"></a>方案</h3><ol><li>应用程序请求访问控制层</li><li>访问控制层 更新Cache</li><li>同步更新DB</li></ol><p><img src="/imgs/%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E9%80%89%E6%8B%A9/d8fffb9a299b42d780486be48c702815~tplv-k3u1fbpfcp-watermark-20220823160159036.png"></p><h3 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h3><h4 id="1-为什么先更新Cache，再更新DB？"><a href="#1-为什么先更新Cache，再更新DB？" class="headerlink" title="1.为什么先更新Cache，再更新DB？"></a>1.为什么先更新Cache，再更新DB？</h4><p>这里顺序关系不大，不管是先更新Cache还是先更新DB，都可能存在之前Cache Aside问题一中提过的脏数据问题。解决办法就是问题四的方式，通过加锁解决并发问题。</p><h4 id="2-如何保证两步操作的原子性？"><a href="#2-如何保证两步操作的原子性？" class="headerlink" title="2.如何保证两步操作的原子性？"></a>2.如何保证两步操作的原子性？</h4><p>俊峰之前也没尝试过这种方案，但可以提出一些自己的想法～</p><p>如果更新Cache失败了，由于是第一步，可以返回异常让客户端重试。</p><p>如果是更新DB失败了，需要看怎么设计，如果希望客户端重试的话，可以把更新Cache回滚。如果不希望客户端重试，可以把失败的请求发送到消息队列中，然后消费该消息补偿失败。</p><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>Write Through通常会和Read Through一同使用，满足读写需求。该方案主要适用于<strong>写请求比较多</strong>的场景，并且对<strong>数据一致性要求较高</strong>的场景，比如银行系统。</p><p>俊峰平时在开发过程很少见到有项目使用Write Through方案，除了必须保证更新Cache和更新DB的原子性会造成一定性能方面的影响外，最主要的是缓存服务的封装是比较难实现的，或者可以接入一些现成的框架，比如Redis官网推荐的<a href="https://github.com/RedisGears/rgsync">RedisGears</a>。</p><h2 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h2><p>Write Behind 又叫 Write Back，意为异步回写模式。它与Read-Through&#x2F;Write-Through 一样，具有类似的访问控制层提供到应用程序。不同的是，Write behind 在处理写请求时，只更新Cache后就返回，对于数据库的更新，则是通过批量<strong>异步</strong>更新的方式进行的，批量写入的时间点可以选在数据库负载较低的时间进行。</p><h3 id="方案-3"><a href="#方案-3" class="headerlink" title="方案"></a>方案</h3><ol><li><p>应用程序请求访问控制层</p></li><li><p>访问控制层 更新Cache</p></li><li><p>异步更新DB</p></li></ol><p><img src="/imgs/%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E9%80%89%E6%8B%A9/2e850d63b568490dab7c8fab0881b810~tplv-k3u1fbpfcp-watermark-20220823160159081.png"></p><h3 id="存在的问题-2"><a href="#存在的问题-2" class="headerlink" title="存在的问题"></a>存在的问题</h3><h4 id="1-异步相比Write-Through带来了哪些好处和问题？"><a href="#1-异步相比Write-Through带来了哪些好处和问题？" class="headerlink" title="1.异步相比Write Through带来了哪些好处和问题？"></a>1.异步相比Write Through带来了哪些好处和问题？</h4><p>在 Write-Behind 模式下，由于不用同步更新DB，写请求延迟大大降低，并减轻了数据库的压力，具有较好的吞吐性。</p><p>但数据库和缓存的一致性较弱，比如当更新的数据还未被写入数据库时，直接从数据库中查询数据是落后于缓存的。同时，缓存的负载较大，如果缓存宕机会导致数据丢失，所以需要做好缓存的高可用（以后会介绍～）。</p><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><p>显然，根据上面的分析，Write behind 模式下非常适合<strong>大量写操作</strong>的场景，比如电商秒杀场景中库存的扣减。</p><p>在之前的文章——<a href="https://juejin.cn/post/7069776553810329613">如何选择一个合适的库存扣减方案？</a>中我们提到过Redis配合lua脚本的方案，实际上和Write Behind思想是一致的，都是先更新Cache，后异步更新DB，只是没有单独封装访问控制层。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>四种缓存方案各有优缺点，这也印证了那句老话，没有最完美的方案，只有最适合的方案。</p><p>俊峰在实际项目中使用的最多的就是Cache Aside（用于Redis），有时候会结合Read Through（用于本地缓存guava）构成二级缓存，后面会单独写一篇文章介绍～</p>]]></content>
    
    
    <categories>
      
      <category>缓存系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>缓存</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String concat和+ 的区别</title>
    <link href="/2022/06/15/String-concat%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/06/15/String-concat%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>字符串</strong>被定义为字符数组。字符数组和字符串的区别在于字符串以特殊字符“\0”结尾。由于数组是不可变的（不能增长），字符串也是不可变的。每当对 String 进行更改时，都会创建一个全新的 String。</p><h2 id="concat-String-str-方法"><a href="#concat-String-str-方法" class="headerlink" title="concat(String str) 方法"></a>concat(String str) 方法</h2><p>concat(String str)方法在String类中声明。此方法返回一个字符串，其中包含传递给该方法的字符串值，附加到当前字符串的末尾。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;在搬砖&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1.concat(s2);<br>        System.out.println(s3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">史俊峰在搬砖<br></code></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="+ 操作"></a>+ 操作</h2><p>同样的，使用 + 连接两个字符串也可以达到上面的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;在搬砖&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br>        System.out.println(s3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>下面来分析两者的区别</p><h3 id="1-参数类型"><a href="#1-参数类型" class="headerlink" title="1.参数类型"></a>1.参数类型</h3><p>concat: 只接受String类型的参数；</p><p>+: 操作可接受任何类型的参数，因为它会在执行之前调用非String类型参数的toString()方法将对象转为String类型。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2 + test;<br>        System.out.println(s3);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;岁&quot;</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">史俊峰24岁<br></code></pre></td></tr></table></figure><h3 id="2-具体执行"><a href="#2-具体执行" class="headerlink" title="2.具体执行"></a>2.具体执行</h3><p>concat: 查看源码，可以看到除了传入的参数是””以外，只要length &gt; 0都返回新的字符串。</p><img src="/imgs/String concat和+ 的区别/image-20211220214923625.png" alt="image-20211220214923625" style="zoom:50%;" /><p>+: 这个不能查看源码，但是可以通过反编译之后得到具体逻辑。源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;在搬砖&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br>        System.out.println(s3);<br>    &#125;<br></code></pre></td></tr></table></figure><p>将会被编译为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;在搬砖&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(s1).append(s2).toString();<br>        System.out.println(s3);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-null的处理"><a href="#3-null的处理" class="headerlink" title="3.null的处理"></a>3.null的处理</h3><p>concat: 参数如果拼接的参数是null，在concat方法内部会抛出NullPointerException，因为方法内没有对参数做null校验而直接使用了str.isEmpty()。</p><p>+: 操作会直接把null作为字符串进行拼接，实际上是因为String。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br>        System.out.println(s3);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1.concat(<span class="hljs-literal">null</span>);<br>        System.out.println(s4);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">史俊峰null<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NullPointerException</span><br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.concat</span>(String<span class="hljs-selector-class">.java</span>:<span class="hljs-number">2027</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java核心技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 参数传递到底是按 值传递 还是 引用传递 ？</title>
    <link href="/2022/06/01/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <url>/2022/06/01/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先明确，<strong>Java中方法参数传递方式是按值传递</strong>。对于基本类型（int a, long b），参数传递时传递的是值，例如int a &#x3D; 5，传递的就是5。如果是引用类型，传递是指向具体对象内存地址的地址值，例如用System.out.println(new Object())打印出来的 java.lang.Object@7716f4 中 @符号后面的7716f4 就是16进制的内存地址，System.out.println实际上是默认调用了对象的toString方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到7716f4是由hashCode()输出的，如果有对象重写了hashCode方法，那输出的有可能就不是对象的初始内存地址了，所以如果要准确获得对象的初始地址建议调用System.identityHashCode()。</p><p>值得一提的是，在Java中获取一个对象的内存地址一般没有什么意义，因为它可能在程序运行过程中随着垃圾回收等动作被JVM更改。不过在下面我们可以根据引用的对象地址是否相同来看看参数传递的各种情况。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="基本类型作为参数传递"><a href="#基本类型作为参数传递" class="headerlink" title="基本类型作为参数传递"></a>基本类型作为参数传递</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//值传递举例</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;改之前的值:&quot;</span> + num);<br>        modify(num);<br>        System.out.println(<span class="hljs-string">&quot;改之后的值:&quot;</span> + num);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> num2)</span> &#123;<br>        num2 = <span class="hljs-number">11</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">改之前的值:<span class="hljs-number">10</span><br>改之后的值:<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>通过这个例子，说明<strong>基本数据类型作为参数传递时，传递的是值的拷贝，无论怎么改变这个拷贝，原值是不会改变的。</strong></p><h3 id="对象作为参数传递"><a href="#对象作为参数传递" class="headerlink" title="对象作为参数传递"></a>对象作为参数传递</h3><p>对象这里可以再划分一下，分为普通对象，集合类型和数组类型。下面依次来看一下效果</p><h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceBasicPass</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; val = x; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVal</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVal</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//普通对象</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;实参 node 指向的内存地址为：&quot;</span> + node.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;改之前的值:&quot;</span> + node.getVal());<br>        modify(node);<br>        System.out.println(<span class="hljs-string">&quot;改之后的值:&quot;</span> + node.getVal());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;形参 node 指向的内存地址为：&quot;</span> + node.hashCode());<br>        <span class="hljs-comment">//引用了同一块地址，操作了同一块堆内存</span><br>        node.setVal(<span class="hljs-number">11</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">实参 <span class="hljs-keyword">node</span> <span class="hljs-title">指向的内存地址为：366712642</span><br>改之前的值:<span class="hljs-number">10</span><br>形参 <span class="hljs-keyword">node</span> <span class="hljs-title">指向的内存地址为：366712642</span><br>改之后的值:<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>这说明，引用对象参数传递时，传递的是指向真实对象的地址，而函数中的形参node拿到同样的地址时，通过node.setVal(11)，会通过地址找到真实的对象进行操作。这里TreeNode没有重写hashCode方法，所以</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>由于ArrayList重写了hashcode()方法，所以这里使用System.identityHashCode拿到地址值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferencePass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//集合对象</span><br>        List&lt;TreeNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>));<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>));<br>        System.out.println(<span class="hljs-string">&quot;修改之前实参 node 指向的内存地址为：&quot;</span> + System.identityHashCode(nodes));<br>        System.out.println(<span class="hljs-string">&quot;修改之前实参 node 指向地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br>        modify(nodes);<br>        System.out.println(<span class="hljs-string">&quot;修改之后实参 node 指向的内存地址为：&quot;</span> + System.identityHashCode(nodes));<br>        System.out.println(<span class="hljs-string">&quot;修改之后实参 node 指向地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br><br>        System.out.println(<span class="hljs-string">&quot;\n------------------------------------------------\n&quot;</span>);<br>        modify2(nodes);<br>        System.out.println(<span class="hljs-string">&quot;再次修改之后实参 node 指向的内存地址为：&quot;</span> + System.identityHashCode(nodes));<br>        System.out.println(<span class="hljs-string">&quot;再次修改之后的实参 nodes 指向地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(List&lt;TreeNode&gt; nodes)</span> &#123;<br>        <span class="hljs-comment">//引用了同一块地址，操作了同一块堆内存</span><br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify2</span><span class="hljs-params">(List&lt;TreeNode&gt; nodes)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;形参 nodes 指向的内存地址：&quot;</span> + nodes.hashCode());<br>        <span class="hljs-comment">//形参nodes 指向了新的内存地址，对其进行操作但是不影响实参指向的内存地址的真实对象</span><br>        nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>));<br>        System.out.println(<span class="hljs-string">&quot;形参 nodes 指向的新内存地址：&quot;</span> + nodes.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;形参 nodes 指向新地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqlite">修改之前实参 node 指向的内存地址为：366712642<br>修改之前实参 node 指向地址存放的对象内容为：[&#123;&quot;val&quot;:1&#125;,&#123;&quot;val&quot;:2&#125;]<br>修改之后实参 node 指向的内存地址为：366712642<br>修改之后实参 node 指向地址存放的对象内容为：[&#123;&quot;val&quot;:1&#125;,&#123;&quot;val&quot;:2&#125;,&#123;&quot;val&quot;:3&#125;]<br><br>------------------------------------------------<br><br>形参 nodes 指向的内存地址：1110478811<br>形参 nodes 指向的新内存地址：1458540949<br>形参 nodes 指向新地址存放的对象内容为：[&#123;&quot;val&quot;:5&#125;]<br>再次修改之后实参 node 指向的内存地址为：366712642<br>再次修改之后的实参 nodes 指向地址存放的对象内容为：[&#123;&quot;val&quot;:1&#125;,&#123;&quot;val&quot;:2&#125;,&#123;&quot;val&quot;:3&#125;]<br></code></pre></td></tr></table></figure><p>对于集合，传递的也是引用的地址，函数内通过形参得到引用地址的拷贝后再操作真实对象，导致实参访问真实对象时已经被修改过了。如果形参指向了新的内存地址，则修改不会影响到原对象的值。</p><p>注：JsonUtils是用Jackson实现的。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>普通数组，和集合一样是引用类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceArrayPass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//普通数组，和集合一样是引用类型，数组本质上也是</span><br>        <span class="hljs-type">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        ints[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        ints[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        System.out.println(<span class="hljs-string">&quot;实参 ints 指向的内存地址为：&quot;</span> + System.identityHashCode(ints));<br>        System.out.println(<span class="hljs-string">&quot;修改之前 ints 索引为2的值&quot;</span> + ints[<span class="hljs-number">2</span>]);<br>        modify(ints);<br>        System.out.println(<span class="hljs-string">&quot;修改之后 ints 索引为2的值&quot;</span> + ints[<span class="hljs-number">2</span>]);<br>        <span class="hljs-comment">//普通数组的class为[I ， I表示int型</span><br>        System.out.println(ints.getClass());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ints)</span> &#123;<br>        <span class="hljs-comment">//引用了同一块地址，操作了同一块堆内存</span><br>        System.out.println(<span class="hljs-string">&quot;形参 ints 指向的内存地址为：&quot;</span> + System.identityHashCode(ints));<br>        ints[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">实参 <span class="hljs-built_in">int</span>s 指向的内存地址为：<span class="hljs-number">366712642</span><br>修改之前 <span class="hljs-built_in">int</span>s 索引为<span class="hljs-number">2</span>的值：<span class="hljs-number">0</span><br>形参 <span class="hljs-built_in">int</span>s 指向的内存地址为：<span class="hljs-number">366712642</span><br>修改之后 <span class="hljs-built_in">int</span>s 索引为<span class="hljs-number">2</span>的值：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>数组与集合的情况也是一样的。</p><h3 id="基本类型的包装类型"><a href="#基本类型的包装类型" class="headerlink" title="基本类型的包装类型"></a>基本类型的包装类型</h3><p>值得注意的是，对于基本类型的包装类型，其参数传递也是属于地址值传递；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//值传递举例</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;before modify result:&quot;</span> + num);<br>        modify(num);<br>        System.out.println(<span class="hljs-string">&quot;after modify result:&quot;</span> + num);<br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">&quot;before modify result:&quot;</span> + integer);<br>        modify(num);<br>        System.out.println(<span class="hljs-string">&quot;after modify result:&quot;</span> + integer);<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> num2)</span> &#123;<br>        num2 = <span class="hljs-number">11</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(Integer integer)</span> &#123;<br>        integer = <span class="hljs-number">21</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">before modify result:<span class="hljs-number">10</span><br>after modify result:<span class="hljs-number">10</span><br>before modify result:<span class="hljs-number">20</span><br>after modify result:<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>而由于jdk1.5以上的自动装箱特性，Integer i &#x3D; 20 等价于执行 Integer i &#x3D; Integer.valueOf(20) ，valueOf()方法参看源码会根据传入的数值 如果在-128-127之间 就从常量池中获取一个Integer对象返回，如果不在范围内 会new Integer(20)返回。</strong></p><img src="/imgs/值传递和引用传递/image-20211124225444095.png" alt="image-20211124225444095" style="zoom:50%;" /><p><strong>即是说Integer的地址会随着值的改变而改变，这其实就是引用类型的赋值，指向了新的内存地址了，例如上面integer &#x3D; 21的例子， 即等价于integer &#x3D; Integer.valueOf(21)，不管21之前是否有创建过，integer都指向了新的内存地址，但是并不影响实参，外部依旧是20</strong></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/1961146/memory-address-of-variables-in-java">https://stackoverflow.com/questions/1961146/memory-address-of-variables-in-java</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java核心技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
