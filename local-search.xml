<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>String concat和+ 的区别</title>
    <link href="/2022/08/21/String-concat%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/08/21/String-concat%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>字符串</strong>被定义为字符数组。字符数组和字符串的区别在于字符串以特殊字符“\0”结尾。由于数组是不可变的（不能增长），字符串也是不可变的。每当对 String 进行更改时，都会创建一个全新的 String。</p><h2 id="concat-String-str-方法"><a href="#concat-String-str-方法" class="headerlink" title="concat(String str) 方法"></a>concat(String str) 方法</h2><p>concat(String str)方法在String类中声明。此方法返回一个字符串，其中包含传递给该方法的字符串值，附加到当前字符串的末尾。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;在搬砖&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1.concat(s2);<br>        System.out.println(s3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">史俊峰在搬砖<br></code></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="+ 操作"></a>+ 操作</h2><p>同样的，使用 + 连接两个字符串也可以达到上面的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;在搬砖&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br>        System.out.println(s3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>下面来分析两者的区别</p><h3 id="1-参数类型"><a href="#1-参数类型" class="headerlink" title="1.参数类型"></a>1.参数类型</h3><p>concat: 只接受String类型的参数；</p><p>+: 操作可接受任何类型的参数，因为它会在执行之前调用非String类型参数的toString()方法将对象转为String类型。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2 + test;<br>        System.out.println(s3);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;岁&quot;</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">史俊峰24岁<br></code></pre></td></tr></table></figure><h3 id="2-具体执行"><a href="#2-具体执行" class="headerlink" title="2.具体执行"></a>2.具体执行</h3><p>concat: 查看源码，可以看到除了传入的参数是””以外，只要length &gt; 0都返回新的字符串。</p><img src="/Users/xiaohai/Library/Application Support/typora-user-images/image-20211220214923625.png" alt="image-20211220214923625" style="zoom:50%;" /><p>+: 这个不能查看源码，但是可以通过反编译之后得到具体逻辑。源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;在搬砖&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br>        System.out.println(s3);<br>    &#125;<br></code></pre></td></tr></table></figure><p>将会被编译为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;在搬砖&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(s1).append(s2).toString();<br>        System.out.println(s3);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-null的处理"><a href="#3-null的处理" class="headerlink" title="3.null的处理"></a>3.null的处理</h3><p>concat: 参数如果拼接的参数是null，在concat方法内部会抛出NullPointerException，因为方法内没有对参数做null校验而直接使用了str.isEmpty()。</p><p>+: 操作会直接把null作为字符串进行拼接，实际上是因为String。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;史俊峰&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br>        System.out.println(s3);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1.concat(<span class="hljs-literal">null</span>);<br>        System.out.println(s4);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">史俊峰null<br>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NullPointerException</span><br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.concat</span>(String<span class="hljs-selector-class">.java</span>:<span class="hljs-number">2027</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java核心技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 参数传递到底是按 值传递 还是 引用传递 ？</title>
    <link href="/2022/08/02/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <url>/2022/08/02/Java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先明确，<strong>Java中方法参数传递方式是按值传递</strong>。对于基本类型（int a, long b），参数传递时传递的是值，例如int a &#x3D; 5，传递的就是5。如果是引用类型，传递是指向具体对象内存地址的地址值，例如用System.out.println(new Object())打印出来的 java.lang.Object@7716f4 中 @符号后面的7716f4 就是16进制的内存地址，System.out.println实际上是默认调用了对象的toString方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到7716f4是由hashCode()输出的，如果有对象重写了hashCode方法，那输出的有可能就不是对象的初始内存地址了，所以如果要准确获得对象的初始地址建议调用System.identityHashCode()。</p><p>值得一提的是，在Java中获取一个对象的内存地址一般没有什么意义，因为它可能在程序运行过程中随着垃圾回收等动作被JVM更改。不过在下面我们可以根据引用的对象地址是否相同来看看参数传递的各种情况。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="基本类型作为参数传递"><a href="#基本类型作为参数传递" class="headerlink" title="基本类型作为参数传递"></a>基本类型作为参数传递</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//值传递举例</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;改之前的值:&quot;</span> + num);<br>        modify(num);<br>        System.out.println(<span class="hljs-string">&quot;改之后的值:&quot;</span> + num);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> num2)</span> &#123;<br>        num2 = <span class="hljs-number">11</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">改之前的值:<span class="hljs-number">10</span><br>改之后的值:<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>通过这个例子，说明<strong>基本数据类型作为参数传递时，传递的是值的拷贝，无论怎么改变这个拷贝，原值是不会改变的。</strong></p><h3 id="对象作为参数传递"><a href="#对象作为参数传递" class="headerlink" title="对象作为参数传递"></a>对象作为参数传递</h3><p>对象这里可以再划分一下，分为普通对象，集合类型和数组类型。下面依次来看一下效果</p><h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceBasicPass</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        TreeNode left;<br>        TreeNode right;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; val = x; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVal</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVal</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//普通对象</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;实参 node 指向的内存地址为：&quot;</span> + node.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;改之前的值:&quot;</span> + node.getVal());<br>        modify(node);<br>        System.out.println(<span class="hljs-string">&quot;改之后的值:&quot;</span> + node.getVal());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;形参 node 指向的内存地址为：&quot;</span> + node.hashCode());<br>        <span class="hljs-comment">//引用了同一块地址，操作了同一块堆内存</span><br>        node.setVal(<span class="hljs-number">11</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">实参 <span class="hljs-keyword">node</span> <span class="hljs-title">指向的内存地址为：366712642</span><br>改之前的值:<span class="hljs-number">10</span><br>形参 <span class="hljs-keyword">node</span> <span class="hljs-title">指向的内存地址为：366712642</span><br>改之后的值:<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>这说明，引用对象参数传递时，传递的是指向真实对象的地址，而函数中的形参node拿到同样的地址时，通过node.setVal(11)，会通过地址找到真实的对象进行操作。这里TreeNode没有重写hashCode方法，所以</p><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>由于ArrayList重写了hashcode()方法，所以这里使用System.identityHashCode拿到地址值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferencePass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//集合对象</span><br>        List&lt;TreeNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>));<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>));<br>        System.out.println(<span class="hljs-string">&quot;修改之前实参 node 指向的内存地址为：&quot;</span> + System.identityHashCode(nodes));<br>        System.out.println(<span class="hljs-string">&quot;修改之前实参 node 指向地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br>        modify(nodes);<br>        System.out.println(<span class="hljs-string">&quot;修改之后实参 node 指向的内存地址为：&quot;</span> + System.identityHashCode(nodes));<br>        System.out.println(<span class="hljs-string">&quot;修改之后实参 node 指向地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br><br>        System.out.println(<span class="hljs-string">&quot;\n------------------------------------------------\n&quot;</span>);<br>        modify2(nodes);<br>        System.out.println(<span class="hljs-string">&quot;再次修改之后实参 node 指向的内存地址为：&quot;</span> + System.identityHashCode(nodes));<br>        System.out.println(<span class="hljs-string">&quot;再次修改之后的实参 nodes 指向地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(List&lt;TreeNode&gt; nodes)</span> &#123;<br>        <span class="hljs-comment">//引用了同一块地址，操作了同一块堆内存</span><br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify2</span><span class="hljs-params">(List&lt;TreeNode&gt; nodes)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;形参 nodes 指向的内存地址：&quot;</span> + nodes.hashCode());<br>        <span class="hljs-comment">//形参nodes 指向了新的内存地址，对其进行操作但是不影响实参指向的内存地址的真实对象</span><br>        nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>));<br>        System.out.println(<span class="hljs-string">&quot;形参 nodes 指向的新内存地址：&quot;</span> + nodes.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;形参 nodes 指向新地址存放的对象内容为：&quot;</span> + JsonUtils.toJson(nodes));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqlite">修改之前实参 node 指向的内存地址为：366712642<br>修改之前实参 node 指向地址存放的对象内容为：[&#123;&quot;val&quot;:1&#125;,&#123;&quot;val&quot;:2&#125;]<br>修改之后实参 node 指向的内存地址为：366712642<br>修改之后实参 node 指向地址存放的对象内容为：[&#123;&quot;val&quot;:1&#125;,&#123;&quot;val&quot;:2&#125;,&#123;&quot;val&quot;:3&#125;]<br><br>------------------------------------------------<br><br>形参 nodes 指向的内存地址：1110478811<br>形参 nodes 指向的新内存地址：1458540949<br>形参 nodes 指向新地址存放的对象内容为：[&#123;&quot;val&quot;:5&#125;]<br>再次修改之后实参 node 指向的内存地址为：366712642<br>再次修改之后的实参 nodes 指向地址存放的对象内容为：[&#123;&quot;val&quot;:1&#125;,&#123;&quot;val&quot;:2&#125;,&#123;&quot;val&quot;:3&#125;]<br></code></pre></td></tr></table></figure><p>对于集合，传递的也是引用的地址，函数内通过形参得到引用地址的拷贝后再操作真实对象，导致实参访问真实对象时已经被修改过了。如果形参指向了新的内存地址，则修改不会影响到原对象的值。</p><p>注：JsonUtils是用Jackson实现的。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>普通数组，和集合一样是引用类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceArrayPass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//普通数组，和集合一样是引用类型，数组本质上也是</span><br>        <span class="hljs-type">int</span>[] ints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        ints[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        ints[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        System.out.println(<span class="hljs-string">&quot;实参 ints 指向的内存地址为：&quot;</span> + System.identityHashCode(ints));<br>        System.out.println(<span class="hljs-string">&quot;修改之前 ints 索引为2的值&quot;</span> + ints[<span class="hljs-number">2</span>]);<br>        modify(ints);<br>        System.out.println(<span class="hljs-string">&quot;修改之后 ints 索引为2的值&quot;</span> + ints[<span class="hljs-number">2</span>]);<br>        <span class="hljs-comment">//普通数组的class为[I ， I表示int型</span><br>        System.out.println(ints.getClass());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ints)</span> &#123;<br>        <span class="hljs-comment">//引用了同一块地址，操作了同一块堆内存</span><br>        System.out.println(<span class="hljs-string">&quot;形参 ints 指向的内存地址为：&quot;</span> + System.identityHashCode(ints));<br>        ints[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">实参 <span class="hljs-built_in">int</span>s 指向的内存地址为：<span class="hljs-number">366712642</span><br>修改之前 <span class="hljs-built_in">int</span>s 索引为<span class="hljs-number">2</span>的值：<span class="hljs-number">0</span><br>形参 <span class="hljs-built_in">int</span>s 指向的内存地址为：<span class="hljs-number">366712642</span><br>修改之后 <span class="hljs-built_in">int</span>s 索引为<span class="hljs-number">2</span>的值：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>数组与集合的情况也是一样的。</p><h3 id="基本类型的包装类型"><a href="#基本类型的包装类型" class="headerlink" title="基本类型的包装类型"></a>基本类型的包装类型</h3><p>值得注意的是，对于基本类型的包装类型，其参数传递也是属于地址值传递；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePass</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//值传递举例</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(<span class="hljs-string">&quot;before modify result:&quot;</span> + num);<br>        modify(num);<br>        System.out.println(<span class="hljs-string">&quot;after modify result:&quot;</span> + num);<br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">&quot;before modify result:&quot;</span> + integer);<br>        modify(num);<br>        System.out.println(<span class="hljs-string">&quot;after modify result:&quot;</span> + integer);<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> num2)</span> &#123;<br>        num2 = <span class="hljs-number">11</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(Integer integer)</span> &#123;<br>        integer = <span class="hljs-number">21</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">before modify result:<span class="hljs-number">10</span><br>after modify result:<span class="hljs-number">10</span><br>before modify result:<span class="hljs-number">20</span><br>after modify result:<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>而由于jdk1.5以上的自动装箱特性，Integer i &#x3D; 20 等价于执行 Integer i &#x3D; Integer.valueOf(20) ，valueOf()方法参看源码会根据传入的数值 如果在-128-127之间 就从常量池中获取一个Integer对象返回，如果不在范围内 会new Integer(20)返回。</strong></p><img src="/Users/xiaohai/Library/Application Support/typora-user-images/image-20211124225444095.png" alt="image-20211124225444095" style="zoom:50%;" /><p><img src="/imgs/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/image-20211124225444095.png"></p><p><strong>即是说Integer的地址会随着值的改变而改变，这其实就是引用类型的赋值，指向了新的内存地址了，例如上面integer &#x3D; 21的例子， 即等价于integer &#x3D; Integer.valueOf(21)，不管21之前是否有创建过，integer都指向了新的内存地址，但是并不影响实参，外部依旧是20</strong></p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/1961146/memory-address-of-variables-in-java">https://stackoverflow.com/questions/1961146/memory-address-of-variables-in-java</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java核心技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
